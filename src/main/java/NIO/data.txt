返回主页 Matrix海 子分享技术与生活！
首页新随笔联系订阅管理
随笔 - 175  文章 - 0  评论 - 1921
Java NIO：浅析I/O模型
　　也许很多朋友在学习NIO的时候都会感觉有点吃力，对里面的很多概念都感觉不是那么明朗。在进入Java NIO编程之前，我们今天先来讨论一些比较基础的知识：I/O模型。下面本文先从同步和异步的概念 说起，然后接着阐述了阻塞和非阻塞的区别，接着介绍了阻塞IO和非阻塞IO的区别，然后介绍了同步IO和异步IO的区别，接下来介绍了5种IO模型，最后介绍了两种和高性能IO设计相关的设计模式（Reactor和Proactor）。

　　以下是本文的目录大纲：

　　一.什么是同步？什么是异步？

　　二.什么是阻塞？什么是非阻塞？

　　三.什么是阻塞IO？什么是非阻塞IO？

　　四.什么是同步IO？什么是异步IO？

　　五.五种IO模型

　　六.两种高性能IO设计模式

　　若有不正之处，请多多谅解并欢迎批评指正。

　　请尊重作者劳动成果，转载请标明原文链接：

 　　http://www.cnblogs.com/dolphin0520/p/3916526.html

一.什么是同步？什么是异步？
　　同步和异步的概念出来已经很久了，网上有关同步和异步的说法也有很多。以下是我个人的理解：

　　同步就是：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行；

　　异步就是：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。

　　这就是同步和异步。举个简单的例子，假如有一个任务包括两个子任务A和B，对于同步来说，当A在执行的过程中，B只有等待，直至A执行完毕，B才能执行；而对于异步就是A和B可以并发地执行，B不必等待A执行完毕之后再执行，这样就不会由于A的执行导致整个任务的暂时等待。

　　如果还不理解，可以先看下面这2段代码：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
void fun1() {

  }

  void fun2() {

  }

  void function(){
      fun1();
      fun2()
      .....
      .....
  }
 　　这段代码就是典型的同步，在方法function中，fun1在执行的过程中会导致后续的fun2无法执行，fun2必须等待fun1执行完毕才可以执行。

　　接着看下面这段代码：

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
void fun1() {

}

void fun2() {

}六.两种高性能IO设计

void function(){
    new Thread(){
        public void run() {
            fun1();
        }
    }.start();

    new Thread(){
        public void run() {
            fun2();
        }
    }.start();

    .....
    .....
}
 　　这段代码是一种典型的异步，fun1的执行不会影响到fun2的执行，并且fun1和fun2的执行不会导致其后续的执行过程处于暂时的等待。

　　事实上，同步和异步是一个非常广的概念，它们的重点在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。我觉得可以将同步和异步与Java中的synchronized关键字联系起来进行类比。当多个线程同时访问一个变量时，每个线程访问该变量就是一个事件，对于同步来说，就是这些线程必须逐个地来访问该变量，一个线程在访问该变量的过程中，其他线程必须等待；而对于异步来说，就是多个线程不必逐个地访问该变量，可以同时进行访问。

　　因此，个人觉得同步和异步可以表现在很多方面，但是记住其关键在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。一般来说，可以通过多线程的方式来实现异步，但是千万记住不要将多线程和异步画上等号，异步只是宏观上的一个模式，采用多线程来实现异步只是一种手段，并且通过多进程的方式也可以实现异步。

二.什么是阻塞？什么是非阻塞？
　　在前面介绍了同步和异步的区别，这一节来看一下阻塞和非阻塞的区别。

　　阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；

　　非阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。

　　这就是阻塞和非阻塞的区别。也就是说阻塞和非阻塞的区别关键在于当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。

　　举个简单的例子：

　　假如我要读取一个文件中的内容，如果此时文件中没有内容可读，对于同步来说就是会一直在那等待，直至文件中有内容可读；而对于非阻塞来说，就会直接返回一个标志信息告知文件中暂时无内容可读。

　　在网上有一些朋友将同步和异步分别与阻塞和非阻塞画上等号，事实上，它们是两组完全不同的概念。注意，理解这两组概念的区别对于后面IO模型的理解非常重要。

　　同步和异步着重点在于多个任务的执行过程中，一个任务的执行是否会导致整个流程的暂时等待；

　　而阻塞和非阻塞着重点在于发出一个请求操作时，如果进行操作的条件不满足是否会返会一个标志信息告知条件不满足。

　　理解阻塞和非阻塞可以同线程阻塞类比地理解，当一个线程进行一个请求操作时，如果条件不满足，则会被阻塞，即在那等待条件满足。

三.什么是阻塞IO？什么是非阻塞IO？
　　在了解阻塞IO和非阻塞IO之前，先看下一个具体的IO操作过程是怎么进行的。

　　通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。

　　当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：

　　1）查看数据是否就绪；

　　2）进行数据拷贝（内核将数据拷贝到用户线程）。

　　那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。

　　Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。

四.什么是同步IO？什么是异步IO？
　　我们先来看一下同步IO和异步IO的定义，在《Unix网络编程》一书中对同步IO和异步IO的定义是这样的：

　　A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes.
　　An asynchronous I/O operation does not cause the requesting process to be blocked.

　　从字面的意思可以看出：同步IO即 如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；

　　而异步IO为 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。

　　事实上，同步IO和异步IO模型是针对用户线程和内核的交互来说的：

　　对于同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程；

　　而异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。

　　这是同步IO和异步IO关键区别所在，同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。

　　注意同步IO和异步IO与阻塞IO和非阻塞IO是不同的两组概念。

　　阻塞IO和非阻塞IO是反映在当用户请求IO操作时，如果数据没有就绪，是用户线程一直等待数据就绪，还是会收到一个标志信息这一点上面的。也就是说，阻塞IO和非阻塞IO是反映在IO操作的第一个阶段，在查看数据是否就绪时是如何处理的。

五.五种IO模型
　　在《Unix网络编程》一书中提到了五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。

　　下面就分别来介绍一下这5种IO模型的异同。

1.阻塞IO模型

　　最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。

　　当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。

　　典型的阻塞IO模型的例子为：

1
data = socket.read();
 　　如果数据没有就绪，就会一直阻塞在read方法。

2.非阻塞IO模型

　　当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。

　　所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。

　　典型的非阻塞IO模型一般如下：

1
2
3
4
5
6
7
while(true){
    data = socket.read();
    if(data!= error){
        处理数据
        break;
    }
}
 　　但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。

3.多路复用IO模型

　　多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。

　　在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。

　　在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。

　　也许有朋友会说，我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。

　　而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。

　　另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。

　　不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。

4.信号驱动IO模型

　　在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。

5.异步IO模型

　　异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。

　　也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。

　　注意，异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。

　　前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。

六.两种高性能IO设计模式
　　在传统的网络服务设计模式中，有两种比较经典的模式：

　　一种是 多线程，一种是线程池。

　　对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件，如下图所示：



　　这种模式虽然处理起来简单方便，但是由于服务器为每个client的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。

　　因此，为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。

　　但是线程池也有它的弊端，如果连接大多是长连接，因此可能会导致在一段时间内，线程池中的线程都被占用，那么当再有用户请求连接时，由于没有可用的空闲线程来处理，就会导致客户端连接失败，从而影响用户体验。因此，线程池比较适合大量的短连接应用。

　　因此便出现了下面的两种高性能IO设计模式：Reactor和Proactor。

　　在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示：



　　从这里可以看出，上面的五种IO模型中的多路复用IO就是采用Reactor模式。注意，上面的图中展示的 是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。

　　在Proactor模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是Proactor模式。

　　参考资料：

　　《Unix网络编程》

　　http://blog.csdn.net/goldensuny/article/details/30717107

　　http://my.oschina.net/XYleung/blog/295122

　　http://xmuzyq.iteye.com/blog/783218

　　http://www.cnblogs.com/ccdev/p/3542669.html

　　http://alicsd.iteye.com/blog/868702

　　http://www.smithfox.com/?e=191

　　http://www.cnblogs.com/Anker/p/3254269.html

　　http://blog.csdn.net/hguisu/article/details/7453390

　　http://www.cnblogs.com/dawen/archive/2011/05/18/2050358.html

　　

作者：Matrix海子
　　　　
出处：http://www.cnblogs.com/dolphin0520/
　　　　
本博客中未标明转载的文章归作者Matrix海子和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。
分类: Java NIO-入门篇
好文要顶 关注我 收藏该文
Matrix海子
关注 - 7
粉丝 - 7364
+加关注
40 1
« 上一篇：Java并发编程：如何创建线程？
» 下一篇：Java NIO：NIO概述
posted @ 2014-08-18 09:48 Matrix海子 阅读(50450) 评论(24) 编辑 收藏

评论列表
   #1楼 2014-08-18 10:40 18dabuda
Java的NIO，版本7之后变得更加丰富，推荐看看这本书
Java 7 New Features Cookbook Java7新特性详解
支持(0)反对(20)
   #2楼 2014-08-18 11:51 寻风问雨
mark
支持(0)反对(0)
   #3楼 2014-08-19 12:28 *深海
这文章写的非常好，赞一个！
支持(0)反对(0)
   #4楼 2015-05-07 18:21 sstong123
好文章！
支持(0)反对(0)
   #5楼 2015-06-26 19:49 倔强的土豆
太棒了写的！
支持(0)反对(0)
   #6楼 2015-07-31 17:51 留香不留名
通俗易懂，深入简出，谢谢！！！
支持(0)反对(0)
   #7楼 2015-10-10 10:02 北冥飞鱼
这种排版方式使用markdown格式生成的吗？请问
支持(0)反对(0)
   #8楼 2015-12-22 19:01 er_bao
@ 18dabuda
MD ，广告
支持(0)反对(0)
   #9楼 2016-02-04 11:53 feichexia
“假如我要读取一个文件中的内容，如果此时文件中没有内容可读，对于同步来说就是会一直在那等待，直至文件中有内容可读；而对于非阻塞来说，就会直接返回一个标志信息告知文件中暂时无内容可读。”存在笔误，应该是“对于阻塞来说”
支持(3)反对(2)
   #10楼 2016-03-12 17:29 mayday芋头
赞一个
支持(0)反对(0)
   #11楼 2016-05-04 16:17 程序诗人
不错。
支持(0)反对(0)
   #12楼 2016-05-11 09:00 kailee
感觉同步和异步解释有点欠妥，同步应该是A线程需要B线程运行的结果，它只能等待B运行出结果，自己才能运行，等待期间自己不能干其他的事情。而异步应该是A不用等待，可以干自己的事情，适时查询A是否运行完毕或者B告诉A自己运行完毕。
建议楼主修改修改吧，同步和异步部分代码写得......这是单线程和多线程的区别，同步和异步都是在多线程情况下发生的吧。
支持(3)反对(1)
   #13楼 2016-08-11 16:03 starsky_blue
楼主写的好清晰，不过有几个细节还有些疑问：
疑问1. 关于IO读取操作的理解，一个完整的IO读请求操作包括两个阶段：
　　1）查看数据是否就绪；
　　2）进行数据拷贝（内核将数据拷贝到用户线程）。
其中第二个阶段，具体指的是什么操作？ 是类似于下面这样的read操作吗？
SocketChannel client = (SocketChannel) selectionKey.channel();
ByteBuffer receivebuffer = ByteBuffer.allocate(1024);
int count = client.read(receivebuffer);

疑问2. 关于同步IO和异步IO的概念描述是不是有些不妥，感觉你描述的跟阻塞IO与非阻塞IO差不多了，我觉得象下面这样描述是不是更好一些呢：
同步IO：多个IO操作同时发生时，其中任何一个IO操作都会阻塞其他IO操作；
异步IO：多个IO操作同时发生时，都同时进行，互不阻塞。
支持(0)反对(0)
   #14楼 2017-11-27 17:55 z也行
多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。


这段有问题，多线程+阻塞IO才是内核去轮询，因为阻塞IO时，进程被挂起，用户线程无法切换线程，必须陷入内核。多路复用是非阻塞的，所以是用户线程来切换，减少陷入内核的消耗。
支持(0)反对(0)
   #15楼 2018-05-19 11:44 aibilim
@ kailee
博主这样写没问题啊.并不一定需要多线程才能说明问题.博主这样写只是想表明两个操作存在制约关系.
支持(0)反对(0)
   #16楼 2018-05-19 11:53 aibilim
@ starsky_blue
你这个同步异步描述的不准确.同步是操作之间的协作方式(类比操作系统中同步操作),两人操作之间,如果B需要等待A.那么在多线程的情况下,即使B先执行了,那么也得阻塞(表现为B不能返回),应为A还没执行完毕.
对于异步,就是B不管Ａ是否执行完毕，自己先返回了结果．
举个例子：
fun(){
// new Thread(B).start();
}
这个地方fun函数并不会等待函数体内的线程任务执行完毕,自己执行完了就先返回了.
支持(0)反对(0)
   #17楼 2018-07-16 20:59 Val1ant
前面部分关于同步异步的解释稍微有些争议，但后面关于IO模型的解释很到位
支持(0)反对(0)
   #18楼 2019-01-30 14:32 蒙奇君杰
谢谢博主的好贴。
关于两种模式
Reactor（反应器）：来一个就处理一个，让线程去处理；
Proactor(促发器)：来一个就推一个，让内核去接收，并完成处理的过程。
支持(0)反对(0)
   #19楼 2019-02-14 08:18 stone_blog
感觉同步异步解释的不够恰当啊，同步异步关注的是通信机制
支持(0)反对(0)
   #20楼 2019-03-25 15:18 minjay26
我这么菜的人看见那个同步和异步的描述都知道是在胡扯,赶紧编辑改改改吧
支持(0)反对(0)
   #21楼[楼主] 2019-03-25 15:22 Matrix海子
@ minjay26
引用
我这么菜的人看见那个同步和异步的描述都知道是在胡扯,赶紧编辑改改改吧

那你的理解是啥？
支持(0)反对(0)
   #22楼 2019-03-26 09:31 大佬不是一天练成的
我记得一个很好的例子：
支持(0)反对(0)
   #23楼 2019-03-26 09:41 大佬不是一天练成的
我记得一个例子：
同步：小明叫我去吃饭，我现在有事去不了，小明就只能一直等我，等到我事情办完了在一起去。
异步：女友叫我去吃饭，我有事去不了，结果女友找了个男的陪她去了，没鸟我。
二者的区别就是，同步必须要等前一个任务（进程执行结束才能进行），而后者是同时进行的。
但是我有一点不解啊，从操作系统来说，都是时间片的问题，我觉得是不是同步是按序执行（FIFO），而异步是其他的方式（算法）呢？恳请楼主解答，万分感谢啊。
支持(0)反对(0)
   #24楼 2019-04-01 20:36 一罪
感谢楼主的分享，不过个人觉得这几点有点问题
1.同步和异步是针对一个线程来说的
同步：在该线程提交任务，并在该线程等待结果返回（执行可以在该线程也可以在其他线程）
异步：在该线程提交任务，但不等待结果直接返回，最终结果通过回调方式通知用户。
比较认同@kailee 的说法

2.非阻塞IO是IO多路复用的基础，如果IO是阻塞的，那么读写超过就绪的数据，这个线程就会阻塞住，哪还能复用。IO多路复用是对轮询模式的改进

3.线程池也是多线程，硬拆分成两种模型感觉有点误导。楼主说的多线程模型是没有限制最大线程数的线程池，而楼主说的线程池只是线程池实现的一种特例，即固定线程数的线程池。线程池的线程只是用来处理事件的执行单元，和连接是长还是短没有关系。前面说的缺陷，只是对线程的用法有问题，而后面引出的Reactor和Proactor只是使用某种合理的方式使用了线程。
支持(0)反对(0)
刷新评论刷新页面返回顶部
注册用户登录后才能发表评论，请 登录 或 注册，访问网站首页。
可扫下方二维码关注公众号：


邮箱：dolphin0520@163.com

昵称：Matrix海子
园龄：8年1个月
粉丝：7364
关注：7
+加关注
最新随笔
1. 深入理解Java中的不可变对象
2. 再议Java中的static关键字
3. 工程实践：如何给变量取一个好的名字
4. 工程实践：给函数取一个"好"的名字
5. 工程实践：如何规范地打印程序日志？
6. 海子微信公众号开通拉
7. 金山快盘+TortoiseSVN构建版本控制仓库
8. 在windows下安装配置Ulipad
9. Java并发编程：线程间协作的两种方式：wait、notify、notifyAll和Condition
10. JAVA多线程和并发基础面试问答（转载）
随笔分类(177)
Android开发(12)
C/C++(29)
Java NIO-入门篇(2)
Java并发编程-入门篇(19)
Java基础-进阶篇(2)
Java基础-入门篇(18)
Linux/Shell(3)
OnlineJudge(14)
Python(16)
工程实践系列(3)
计算机基础&网络(1)
开发工具(7)
设计模式(1)
生活有感(1)
数据库(2)
算法与数据结构(36)
业余娱乐(1)
杂项(2)
装机数码系列(8)
随笔档案(175)
2019年4月 (3)
2019年3月 (3)
2014年10月 (2)
2014年9月 (7)
2014年8月 (15)
2014年7月 (4)
2014年6月 (10)
2014年5月 (9)
2014年4月 (5)
2014年1月 (1)
2013年11月 (4)
2013年10月 (3)
2013年8月 (2)
2013年6月 (1)
2013年5月 (3)
2013年4月 (3)
2013年3月 (11)
2013年1月 (4)
2012年11月 (3)
2012年10月 (4)
2012年9月 (3)
2012年8月 (2)
2012年4月 (1)
2012年3月 (1)
2011年12月 (2)
2011年11月 (5)
2011年10月 (20)
2011年9月 (2)
2011年8月 (3)
2011年7月 (10)
2011年4月 (29)
积分与排名
积分 -	456379
排名 -	426
最新评论
1. Re:Java并发编程：volatile关键字解析
不好意思，有个地方有点不理解，在32位机器中，i = 9，为什么会被分成低16位和高16位？貌似只有long ,double在会被分成低32和高32吧。
--RUSSELLj
2. Re:浅析Java中的final关键字
对于string类型的特殊情况，个人觉得是调用
System.out.println(a.equals(e));
去看做一个类，用equals方法去解决比这样不明不白能避免犯错
--禺_心
3. Re:浅析Java中的final关键字
我用基本数据类型int比较了下，发现结果与string类型有出入 int t1 = 1; final int t2 = 2; int t3 = 2; int t4 = t2 -1; int ...........
--禺_心
阅读排行榜
1. Java并发编程：线程池的使用(633557)
2. Java并发编程：volatile关键字解析(394722)
3. Java中的static关键字解析(372930)
4. 深入理解Java的接口和抽象类(359855)
5. Java ConcurrentModificationException异常原因和解决方法(333198)
Copyright ©2019 Matrix海子

喜欢请打赏
微信微信
扫描二维码打赏


微信打赏